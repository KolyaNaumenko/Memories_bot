import os
import re
import asyncio
from datetime import datetime, timedelta, time as dtime
from dateutil.relativedelta import relativedelta
from apscheduler.schedulers.background import BackgroundScheduler
import matplotlib.pyplot as plt
import yake
from telegram.constants import ParseMode
from snownlp import SnowNLP
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    BotCommand,
)
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    CommandHandler,
)

from database import (
    add_entry_to_db,
    get_entries,
    delete_entry_from_db,
    add_goal_to_db,
    get_goals_from_db,
    update_goal_status_in_db,
    delete_goal_from_db,
    update_entry_in_db,
    get_random_entry,
    search_entries
)
# –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π
analyzer = SentimentIntensityAnalyzer()
_vader = SentimentIntensityAnalyzer()

IMAGE_FOLDER = "images"
if not os.path.exists(IMAGE_FOLDER):
    os.makedirs(IMAGE_FOLDER)
# –°—Ç–∞—Ç—É—Å –¥–ª—è –∫–æ–º–∞–Ω–¥—ã /add
WAITING_FOR_ENTRY = 12
# –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è ConversationHandler
WAITING_EDIT = 1
# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):

    # 2) –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å HTML-—Ä–∞–∑–º–µ—Ç–∫–æ–π
    text = (
        "<b>üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≤–∞—à –õ–∏—á–Ω—ã–π –î–Ω–µ–≤–Ω–∏–∫!</b>\n\n"
        "<i>–í–æ—Ç —á—Ç–æ —è —É–º–µ—é:</i>\n"
        "üìù <b>/add</b> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å (—Ç–µ–∫—Å—Ç –∏–ª–∏ —Ñ–æ—Ç–æ)\n"
        "üìñ <b>/view_all</b> ‚Äî –≤—Å–µ –∑–∞–ø–∏—Å–∏\n"
        "üìÖ <b>/view_day</b> ‚Äî –∑–∞ —Å–µ–≥–æ–¥–Ω—è\n"
        "üóìÔ∏è <b>/view_week</b> ‚Äî –∑–∞ –Ω–µ–¥–µ–ª—é\n"
        "üìÜ <b>/view_month</b> ‚Äî –∑–∞ –º–µ—Å—è—Ü\n\n"
        "üîç <b>/search</b> ‚Äî –ø–æ–∏—Å–∫ –ø–æ –∑–∞–ø–∏—Å—è–º\n"
        "üí¨ <b>/random</b> ‚Äî —Å–ª—É—á–∞–π–Ω–∞—è –∑–∞–ø–∏—Å—å\n"
        "üìä <b>/stats</b> ‚Äî –≥—Ä–∞—Ñ–∏–∫ —á–∏—Å–ª–∞ –∑–∞–ø–∏—Å–µ–π –∑–∞ 30 –¥–Ω–µ–π\n"
        "üòä <b>/sentiment_days</b> ‚Äî —Ç—Ä–µ–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ø–æ –¥–Ω—è–º\n"
        "üòä <b>/sentiment_weeks</b> ‚Äî —Ç—Ä–µ–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ø–æ –Ω–µ–¥–µ–ª—è–º\n"
        "üòä <b>/sentiment_months</b> ‚Äî —Ç—Ä–µ–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ø–æ –º–µ—Å—è—Ü–∞–º\n"
        "üìÑ <b>/summary_week</b> ‚Äî –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –∑–∞ –Ω–µ–¥–µ–ª—é\n"
        "üìÑ <b>/summary_month</b> ‚Äî –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –∑–∞ –º–µ—Å—è—Ü\n\n"
        "üéØ <b>/add_goal</b> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å —Å –¥–µ–¥–ª–∞–π–Ω–æ–º\n"
        "üìã <b>/list_goals</b> ‚Äî —Å–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π\n"
        "‚úÖ <b>/mark_goal</b> ‚Äî –æ—Ç–º–µ—Ç–∏—Ç—å —Ü–µ–ª—å\n"
        "‚ùå <b>/delete_goal</b> ‚Äî —É–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å\n"
        "üìà <b>/goal_report</b> ‚Äî –æ—Ç—á–µ—Ç –ø–æ —Ü–µ–ª—è–º\n\n"
        "üîî –Ø –±—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å:\n"
        "‚Ä¢ –ö–∞–∂–¥—ã–π –≤–µ—á–µ—Ä –≤ <b>20:00</b> ‚Äî —Å–¥–µ–ª–∞—Ç—å –∑–∞–ø–∏—Å—å\n"
        "‚Ä¢ –ö–∞–∂–¥–æ–µ –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –≤ <b>09:00</b> ‚Äî –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –¥–∞–π–¥–∂–µ—Å—Ç\n\n"
        "<i>–ß—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–Ω–æ–≤–∞ ‚Äî /start</i>"
    )
    await update.message.reply_text(text, parse_mode=ParseMode.HTML)

    # 3) –ü–ª–∞–Ω–∏—Ä—É–µ–º –∑–∞–¥–∞—á–∏
    context.job_queue.run_daily(
        daily_entry_prompt,
        time=dtime(hour=20, minute=0),
        context=update.effective_user.id,
    )
    context.job_queue.run_daily(
        weekly_digest,
        time=dtime(hour=9, minute=0),
        days=(6,),
        context=update.effective_user.id,
    )


# –ö–æ–º–∞–Ω–¥–∞ /help
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "<b>üí° –ü–æ–º–æ—â—å –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:</b>\n\n"
        "üìù <b>/add</b> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å (—Ç–µ–∫—Å—Ç –∏–ª–∏ —Ñ–æ—Ç–æ)\n"
        "üìñ <b>/view_all</b> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∑–∞–ø–∏—Å–∏\n"
        "üìÖ <b>/view_day</b> ‚Äî –∑–∞ —Å–µ–≥–æ–¥–Ω—è\n"
        "üóìÔ∏è <b>/view_week</b> ‚Äî –∑–∞ –Ω–µ–¥–µ–ª—é\n"
        "üìÜ <b>/view_month</b> ‚Äî –∑–∞ –º–µ—Å—è—Ü\n\n"
        "üîç <b>/search</b> ‚Äî –ø–æ–∏—Å–∫ –ø–æ –∑–∞–ø–∏—Å—è–º\n"
        "üí¨ <b>/random</b> ‚Äî —Å–ª—É—á–∞–π–Ω–∞—è –∑–∞–ø–∏—Å—å\n"
        "üìä <b>/stats</b> ‚Äî –≥—Ä–∞—Ñ–∏–∫ —á–∏—Å–ª–∞ –∑–∞–ø–∏—Å–µ–π –∑–∞ 30 –¥–Ω–µ–π\n"
        "üòä <b>/sentiment_days</b> ‚Äî —Ç—Ä–µ–Ω–¥ –ø–æ –¥–Ω—è–º\n"
        "üòä <b>/sentiment_weeks</b> ‚Äî —Ç—Ä–µ–Ω–¥ –ø–æ –Ω–µ–¥–µ–ª—è–º\n"
        "üòä <b>/sentiment_months</b> ‚Äî —Ç—Ä–µ–Ω–¥ –ø–æ –º–µ—Å—è—Ü–∞–º\n"
        "üìÑ <b>/summary_week</b> ‚Äî —Ä–µ–∑—é–º–µ –∑–∞ –Ω–µ–¥–µ–ª—é\n"
        "üìÑ <b>/summary_month</b> ‚Äî —Ä–µ–∑—é–º–µ –∑–∞ –º–µ—Å—è—Ü\n\n"
        "üéØ <b>/add_goal</b> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å —Å –¥–µ–¥–ª–∞–π–Ω–æ–º\n"
        "üìã <b>/list_goals</b> ‚Äî —Å–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π\n"
        "‚úÖ <b>/mark_goal</b> ‚Äî –æ—Ç–º–µ—Ç–∏—Ç—å —Ü–µ–ª—å\n"
        "‚ùå <b>/delete_goal</b> ‚Äî —É–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å\n"
        "üìà <b>/goal_report</b> ‚Äî –æ—Ç—á–µ—Ç –ø–æ —Ü–µ–ª—è–º\n\n"
        "–ß—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî /start"
    )
    await update.message.reply_text(text, parse_mode=ParseMode.HTML)

# –ö–æ–º–∞–Ω–¥–∞ /add
async def add_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚úèÔ∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∑–∞–ø–∏—Å–∏!")
    return WAITING_FOR_ENTRY

# –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ save_entry
async def save_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        message = update.message

        # 1) –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∏ —Ñ–æ—Ç–æ
        entry_text = message.text.strip() if message.text else ""
        photos = message.photo or []
        image_paths = []

        # 2) –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–æ—Ç–æ
        if photos:
            os.makedirs(IMAGE_FOLDER, exist_ok=True)
            largest = photos[-1]
            file = await context.bot.get_file(largest.file_id)
            name = f"{user_id}_{re.sub(r'[^a-zA-Z0-9]', '_', largest.file_id)}.jpg"
            path = os.path.join(IMAGE_FOLDER, name)
            await file.download_to_drive(path)
            image_paths.append(path)

        if not entry_text and not image_paths:
            return await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ —Ñ–æ—Ç–æ –¥–ª—è –∑–∞–ø–∏—Å–∏.")

        image_paths_str = ",".join(image_paths) if image_paths else None

        # 3) –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É
        add_entry_to_db(user_id, date, entry_text, image_paths_str)

        # 4) –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        resp = f"‚úÖ –ó–∞–ø–∏—Å—å –¥–æ–±–∞–≤–ª–µ–Ω–∞!\nüìÖ {date}\n"
        if entry_text:
            resp += f"üìù {entry_text}\n"
        if image_paths:
            resp += f"üñºÔ∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(image_paths)}"
        await update.message.reply_text(resp, parse_mode="Markdown")

        # 5) –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ ‚Äî ¬´–í—Å–ø–æ–º–Ω–∏—Ç–µ, –∫–∞–∫ —ç—Ç–æ –±—ã–ª–æ¬ª –∫–∞–∂–¥—ã–µ 10 –∑–∞–ø–∏—Å–µ–π
        all_entries = get_entries(user_id)
        if len(all_entries) % 10 == 0:
            old = get_random_entry(user_id)
            if old:
                r_date, r_text, r_imgs = old
                reminder = f"üí≠ –í—Å–ø–æ–º–Ω–∏—Ç–µ, –∫–∞–∫ —ç—Ç–æ –±—ã–ª–æ:\nüìÖ {r_date}"
                if r_text:
                    reminder += f"\nüìù {r_text}"
                await context.bot.send_message(chat_id=update.effective_chat.id, text=reminder)
                if r_imgs:
                    for p in r_imgs.split(","):
                        if os.path.exists(p):
                            with open(p, "rb") as img_f:
                                await context.bot.send_photo(chat_id=update.effective_chat.id, photo=img_f)

    except Exception as e:
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–ø–∏—Å–∏.")
        print(f"save_entry error: {e}")

async def random_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /random ‚Äî –≤—ã–±—Ä–æ—Å–∏—Ç—å —Å–ª—É—á–∞–π–Ω—É—é –∑–∞–ø–∏—Å—å –∏–∑ –∞—Ä—Ö–∏–≤–∞
    """
    user_id = update.effective_user.id
    entry = get_random_entry(user_id)
    if not entry:
        return await update.message.reply_text("üì≠ –£ –≤–∞—Å –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–π —Ü–∏—Ç–∞—Ç—ã.")
    r_date, r_text, r_imgs = entry

    msg = f"üí¨ –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–ø–∏—Å—å:\nüìÖ {r_date}"
    if r_text:
        msg += f"\nüìù {r_text}"
    await update.message.reply_text(msg)

    if r_imgs:
        for p in r_imgs.split(","):
            if os.path.exists(p):
                with open(p, "rb") as img_f:
                    await context.bot.send_photo(chat_id=update.effective_chat.id, photo=img_f)

# –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è –≤—ã–≤–æ–¥–∞
def format_entry(date, entry_text, image_paths_str):
    formatted_entry = f"üìÖ {date}\n"
    if entry_text:
        formatted_entry += f"üìù {entry_text}\n"
    if image_paths_str:
        image_paths = image_paths_str.split(",")  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –≤ —Å–ø–∏—Å–æ–∫
        formatted_entry += f"üñºÔ∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(image_paths)}\n"
    return formatted_entry

# –û—Ç–º–µ–Ω–∞ –∫–æ–º–∞–Ω–¥—ã
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É /add.")
    return ConversationHandler.END


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–≤–æ–¥–∞ –∑–∞–ø–∏—Å–µ–π
async def view_records(update: Update, context: ContextTypes.DEFAULT_TYPE, time_filter: str = None):
    from telegram import InlineKeyboardMarkup, InlineKeyboardButton
    import asyncio
    import os

    user_id = update.effective_user.id
    now = datetime.now()
    start_date = end_date = None

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –ø–æ —Ñ–∏–ª—å—Ç—Ä—É
    if time_filter == "day":
        start_date = now.strftime("%Y-%m-%d 00:00:00")
        end_date   = now.strftime("%Y-%m-%d 23:59:59")
    elif time_filter == "week":
        start_date = (now - timedelta(days=now.weekday())).strftime("%Y-%m-%d 00:00:00")
        end_date   = (now + timedelta(days=6 - now.weekday())).strftime("%Y-%m-%d 23:59:59")
    elif time_filter == "month":
        start_date = now.strftime("%Y-%m-01 00:00:00")
        nxt = now.replace(day=28) + timedelta(days=4)
        end_date   = nxt.replace(day=1).strftime("%Y-%m-%d 00:00:00")

    # –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å–∏ —Å id
    entries = get_entries(user_id, start_date, end_date)
    if not entries:
        text = "üì≠ –£ –≤–∞—Å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π." if time_filter is None else "üì≠ –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –ø–µ—Ä–∏–æ–¥."
        await update.message.reply_text(text)
        return

    for idx, (entry_id, date_str, entry_text, image_paths_str) in enumerate(entries, start=1):
        # –ê–Ω–∞–ª–∏–∑ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
        if entry_text:
            compound = get_sentiment_score(entry_text)
            if compound > 0.05:
                label = "‚úÖ –ü–æ–∑–∏—Ç–∏–≤–Ω—ã–π"
            elif compound < -0.05:
                label = "‚ö†Ô∏è –ù–µ–≥–∞—Ç–∏–≤–Ω—ã–π"
            else:
                label = "‚ÑπÔ∏è –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π"
        else:
            label = "‚ÑπÔ∏è –ù–µ—Ç —Ç–µ–∫—Å—Ç–∞"

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        msg = f"{idx}. üìÖ {date_str}\n{label}"
        if entry_text:
            msg += f"\nüìù {entry_text}"
        if image_paths_str:
            count = len(image_paths_str.split(","))
            msg += f"\nüñºÔ∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {count}"

        # Inline-–∫–Ω–æ–ø–∫–∏ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —É–¥–∞–ª–µ–Ω–∏—è
        keyboard = InlineKeyboardMarkup([[
            InlineKeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit:{entry_id}"),
            InlineKeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å",        callback_data=f"delete:{entry_id}")
        ]])

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
        await update.message.reply_text(msg, reply_markup=keyboard)

        # –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        if image_paths_str:
            for path in image_paths_str.split(","):
                if os.path.exists(path):
                    with open(path, "rb") as img:
                        await context.bot.send_photo(chat_id=update.effective_chat.id, photo=img)
                else:
                    await update.message.reply_text(f"‚ö†Ô∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ: {path}")

        # –ü–∞—É–∑–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å Flood 429
        await asyncio.sleep(0.3)

    # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ —É–¥–∞–ª–µ–Ω–∏—é
    await update.message.reply_text(
        "‚úÖ –í—Å–µ –∑–∞–ø–∏—Å–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.\n"
        "‚ùå –ß—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å, –Ω–∞–∂–º–∏—Ç–µ ¬´‚ùå –£–¥–∞–ª–∏—Ç—å¬ª –ø–æ–¥ –Ω—É–∂–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n"
        "‚úèÔ∏è –ß—Ç–æ–±—ã –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å ‚Äî ¬´‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å¬ª."
    )

async def delete_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–µ—Ä–µ–¥–∞–Ω –ª–∏ –Ω–æ–º–µ—Ä –∑–∞–ø–∏—Å–∏
    if not context.args or not context.args[0].isdigit():
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä: /delete 1")
        return

    # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–º–µ—Ä –∑–∞–ø–∏—Å–∏
    record_number = int(context.args[0])

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω)
    time_filter = context.chat_data.get("time_filter", None)
    now = datetime.now()
    start_date, end_date = None, None

    if time_filter == "day":
        start_date = now.strftime("%Y-%m-%d 00:00:00")
        end_date = now.strftime("%Y-%m-%d 23:59:59")
    elif time_filter == "week":
        start_date = (now - timedelta(days=now.weekday())).strftime("%Y-%m-%d 00:00:00")
        end_date = (now + timedelta(days=(6 - now.weekday()))).strftime("%Y-%m-%d 23:59:59")
    elif time_filter == "month":
        start_date = now.strftime("%Y-%m-01 00:00:00")
        next_month = now.replace(day=28) + timedelta(days=4)
        end_date = next_month.replace(day=1).strftime("%Y-%m-%d 00:00:00")

    # –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å–∏ —Å —É—á—ë—Ç–æ–º —Ñ–∏–ª—å—Ç—Ä–∞
    entries = get_entries(user_id, start_date, end_date)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –Ω–æ–º–µ—Ä–∞ –∑–∞–ø–∏—Å–∏
    if record_number < 1 or record_number > len(entries):
        await update.message.reply_text("‚ö†Ô∏è –ó–∞–ø–∏—Å—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–æ–º–µ—Ä –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    # –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å—å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    entry = entries[record_number - 1]
    date, text, image_paths_str = entry

    # –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –±–∞–∑—ã
    delete_entry_from_db(user_id, date)

    # –£–¥–∞–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
    if image_paths_str:
        image_paths = image_paths_str.split(",")
        for image_path in image_paths:
            try:
                os.remove(image_path)
            except FileNotFoundError:
                pass

    await update.message.reply_text(f"‚úÖ –ó–∞–ø–∏—Å—å #{record_number} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–ø–∏—Å–µ–π
async def view_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await view_records(update, context, time_filter=None)

async def view_day(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await view_records(update, context, time_filter="day")

async def view_week(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await view_records(update, context, time_filter="week")

async def view_month(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await view_records(update, context, time_filter="month")
async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /search –∫–ª—é—á–µ–≤–æ–µ_—Å–ª–æ–≤–æ ‚Äî –∏—â–µ—Ç –≤ —Ç–µ–∫—Å—Ç–µ –≤—Å–µ—Ö –∑–∞–ø–∏—Å–µ–π
    """
    user_id = update.effective_user.id

    # –°–æ–±–∏—Ä–∞–µ–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ
    if not context.args:
        return await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Å–ª–æ–≤–æ –¥–ª—è –ø–æ–∏—Å–∫–∞. –ü—Ä–∏–º–µ—Ä: /search –≤–∞–∂–Ω–æ–µ"
        )
    keyword = " ".join(context.args).strip()

    # –ò—â–µ–º –≤ –ë–î
    entries = search_entries(user_id, keyword)
    if not entries:
        return await update.message.reply_text(f"üîé –ü–æ –∑–∞–ø—Ä–æ—Å—É ¬´{keyword}¬ª –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    for idx, (date_str, text, image_paths_str) in enumerate(entries, start=1):
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        msg = f"{idx}. üìÖ {date_str}\nüìù {text}"
        await update.message.reply_text(msg)

        # –§–æ—Ç–æ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if image_paths_str:
            for path in image_paths_str.split(","):
                try:
                    with open(path, "rb") as img:
                        await context.bot.send_photo(chat_id=update.effective_chat.id, photo=img)
                except FileNotFoundError:
                    await update.message.reply_text(f"‚ö†Ô∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ: {path}")

        # –ü–∞—É–∑–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ–ª—É—á–∏—Ç—å Flood-—Ñ–∞–π–ª—Ç
        await asyncio.sleep(0.2)


scheduler = BackgroundScheduler()
scheduler.start()

async def daily_entry_prompt(context: ContextTypes.DEFAULT_TYPE):
    user_id = context.job.data
    await context.bot.send_message(
        chat_id=user_id,
        text="‚úçÔ∏è –ù–µ –∑–∞–±—É–¥—å—Ç–µ —Å–µ–≥–æ–¥–Ω—è —Å–¥–µ–ª–∞—Ç—å –∑–∞–ø–∏—Å—å –≤ –¥–Ω–µ–≤–Ω–∏–∫!"
    )

# –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –¥–∞–π–¥–∂–µ—Å—Ç –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π
async def weekly_digest(context: ContextTypes.DEFAULT_TYPE):
    user_id = context.job.data
    now = datetime.now()
    # –ë–µ—Ä—ë–º –∑–∞–ø–∏—Å–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π
    start_dt = (now - timedelta(days=7)).replace(hour=0, minute=0, second=0)
    start_date = start_dt.strftime("%Y-%m-%d %H:%M:%S")
    end_date   = now.strftime("%Y-%m-%d %H:%M:%S")

    entries = get_entries(user_id, start_date, end_date)
    total = len(entries)

    # –°—á–∏—Ç–∞–µ–º —Å—Ä–µ–¥–Ω–µ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ
    sentiments = [
        get_sentiment_score(text)
        for _, text, _ in entries
        if text
    ]
    avg = sum(sentiments) / len(sentiments) if sentiments else 0
    if avg > 0.05:
        mood = '–ø–æ–∑–∏—Ç–∏–≤–Ω–æ–µ'
    elif avg < -0.05:
        mood = '–Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–µ'
    else:
        mood = '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ'

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–π–¥–∂–µ—Å—Ç
    message = (
        f"üìÖ –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π –¥–∞–π–¥–∂–µ—Å—Ç ({start_dt.strftime('%Y-%m-%d')} ‚Äî {now.strftime('%Y-%m-%d')}):\n"
        f"‚úèÔ∏è –ó–∞–ø–∏—Å–µ–π: {total}\n"
        f"üòä –°—Ä–µ–¥–Ω–µ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {avg:.2f} ({mood})"
    )
    await context.bot.send_message(chat_id=user_id, text=message)


# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Ü–µ–ª–∏
async def add_goal(update, context):
    try:
        user_id = update.effective_user.id
        message = update.message.text
        goal_data = message.replace("/add_goal", "").strip()  # –£–±–∏—Ä–∞–µ–º –∫–æ–º–∞–Ω–¥—É

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–∫–∞–∑–∞–Ω—ã –ª–∏ —Ü–µ–ª—å –∏ –¥–µ–¥–ª–∞–π–Ω
        if not goal_data:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Ü–µ–ª—å. –ü—Ä–∏–º–µ—Ä: `/add_goal –ü—Ä–æ—á–∏—Ç–∞—Ç—å –∫–Ω–∏–≥—É 2024-12-30` –∏–ª–∏ `/add_goal –ü—Ä–æ—á–∏—Ç–∞—Ç—å –∫–Ω–∏–≥—É` –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ 12:00.",
                parse_mode="Markdown"
            )
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤ –∫–æ–º–∞–Ω–¥–µ —É–∫–∞–∑–∞–Ω–Ω–∞—è –¥–∞—Ç–∞ (–¥–µ–¥–ª–∞–π–Ω)
        try:
            # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç - —ç—Ç–æ –¥–µ–¥–ª–∞–π–Ω
            *goal_parts, possible_deadline = goal_data.rsplit(maxsplit=1)
            goal_text = " ".join(goal_parts).strip()  # –¶–µ–ª—å - –≤—Å—ë, –∫—Ä–æ–º–µ –¥–µ–¥–ª–∞–π–Ω–∞

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç - —ç—Ç–æ –¥–∞—Ç–∞ –∏–ª–∏ –¥–∞—Ç–∞ —Å –≤—Ä–µ–º–µ–Ω–µ–º
            if len(possible_deadline) == 10:  # –§–æ—Ä–º–∞—Ç YYYY-MM-DD
                deadline_str = f"{possible_deadline} 12:00"
            else:
                deadline_str = possible_deadline  # –§–æ—Ä–º–∞—Ç YYYY-MM-DD HH:MM

            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –¥–µ–¥–ª–∞–π–Ω–∞ –≤ datetime
            deadline = datetime.strptime(deadline_str, "%Y-%m-%d %H:%M")
        except (ValueError, IndexError):  # –ï—Å–ª–∏ –¥–µ–¥–ª–∞–π–Ω –Ω–µ —É–∫–∞–∑–∞–Ω –∏–ª–∏ —É–∫–∞–∑–∞–Ω –Ω–µ–≤–µ—Ä–Ω–æ
            goal_text = goal_data  # –í—Å—ë —Å–æ–æ–±—â–µ–Ω–∏–µ - —Ü–µ–ª—å
            deadline = datetime.now().replace(hour=12, minute=0, second=0, microsecond=0)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–µ–∫—Å—Ç —Ü–µ–ª–∏
        if not goal_text:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç —Ü–µ–ª–∏. –ü—Ä–∏–º–µ—Ä: `/add_goal –ü—Ä–æ—á–∏—Ç–∞—Ç—å –∫–Ω–∏–≥—É 2024-12-30`.",
                parse_mode="Markdown"
            )
            return

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ü–µ–ª—å –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        add_goal_to_db(user_id, goal_text, deadline)

        # –ü–ª–∞–Ω–∏—Ä—É–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
        await schedule_reminders(context, user_id, goal_text, deadline)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        await update.message.reply_text(
            f"üéØ –¶–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω–∞: *{goal_text}*\nüïí –î–µ–¥–ª–∞–π–Ω: {deadline.strftime('%Y-%m-%d %H:%M')}",
            parse_mode="Markdown"
        )
    except Exception as e:
        await update.message.reply_text(
            "‚ùå –û—à–∏–±–∫–∞! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç: `/add_goal –¶–µ–ª—å YYYY-MM-DD HH:MM` –∏–ª–∏ `/add_goal –¶–µ–ª—å` –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ 12:00."
        )
        print(e)

async def schedule_reminders(context, user_id, goal_text, deadline):
    job_queue = context.job_queue

    # –†–∞—Å—á—ë—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫ –¥–ª—è —Ç—Ä—ë—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
    now = datetime.now()
    total_seconds = (deadline - now).total_seconds()

    if total_seconds <= 0:
        return  # –ï—Å–ª–∏ –¥–µ–¥–ª–∞–π–Ω —É–∂–µ –ø—Ä–æ—à—ë–ª, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –Ω–µ –ø–ª–∞–Ω–∏—Ä—É—é—Ç—Å—è

    reminder_intervals = [total_seconds / 4, total_seconds / 2, (3 * total_seconds) / 4]
    reminder_times = [now + timedelta(seconds=interval) for interval in reminder_intervals]

    for reminder_time in reminder_times:
        job_queue.run_once(
            reminder_callback,
            when=(reminder_time - now),
            data={"user_id": user_id, "goal_text": goal_text, "deadline": deadline},
        )

async def reminder_callback(job):
    data = job.data
    user_id = data["user_id"]
    goal_text = data["goal_text"]
    deadline = data["deadline"]

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    await job.application.bot.send_message(
        chat_id=user_id,
        text=f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!\n–¶–µ–ª—å: {goal_text}\nüïí –î–µ–¥–ª–∞–π–Ω: {deadline.strftime('%Y-%m-%d %H:%M')}"
    )

# –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ü–µ–ª–∏
async def list_goals(update, context):
    user_id = update.effective_user.id
    goals = get_goals_from_db(user_id)

    if not goals:
        await update.message.reply_text("üìã –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Ü–µ–ª–µ–π.")
        return

    response = "üéØ –í–∞—à–∏ —Ü–µ–ª–∏:\n"
    for idx, (goal_id, goal_text, deadline, status) in enumerate(goals, start=1):
        response += f"{idx}. {goal_text} (–¥–æ {deadline}) ‚Äî {status.capitalize()}\n"
    await update.message.reply_text(response)

# –û—Ç–º–µ—Ç–∏—Ç—å —Ü–µ–ª—å –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é –∏–ª–∏ –ø—Ä–æ–≤–∞–ª–µ–Ω–Ω—É—é
async def mark_goal(update, context):
    if len(context.args) < 2:
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä —Ü–µ–ª–∏ –∏ —Å—Ç–∞—Ç—É—Å (completed/failed). –ü—Ä–∏–º–µ—Ä: /mark_goal 1 completed")
        return

    goal_id = int(context.args[0])
    status = context.args[1]

    if status not in ["completed", "failed"]:
        await update.message.reply_text("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Å—Ç–∞—Ç—É—Å. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: completed –∏–ª–∏ failed.")
        return

    update_goal_status_in_db(goal_id, status)
    await update.message.reply_text(f"‚úÖ –°—Ç–∞—Ç—É—Å —Ü–µ–ª–∏ #{goal_id} –æ–±–Ω–æ–≤–ª—ë–Ω: {status.capitalize()}")

# –£–¥–∞–ª–µ–Ω–∏–µ —Ü–µ–ª–∏
async def delete_goal(update, context):
    if not context.args or not context.args[0].isdigit():
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä —Ü–µ–ª–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä: /delete_goal 1")
        return

    goal_id = int(context.args[0])
    delete_goal_from_db(goal_id)
    await update.message.reply_text(f"‚úÖ –¶–µ–ª—å #{goal_id} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞.")

# –û—Ç—á–µ—Ç –æ —Ü–µ–ª—è—Ö
async def goal_report(update, context):
    user_id = update.effective_user.id
    goals = get_goals_from_db(user_id)

    completed = [g for g in goals if g[3] == "completed"]
    failed = [g for g in goals if g[3] == "failed"]

    response = "üìä –û—Ç—á–µ—Ç –æ —Ü–µ–ª—è—Ö:\n"
    response += f"‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {len(completed)}\n"
    response += f"‚ùå –ü—Ä–æ–≤–∞–ª–µ–Ω–æ: {len(failed)}\n"

    if completed:
        response += "\nüéâ –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Ü–µ–ª–∏:\n"
        for goal in completed:
            response += f"- {goal[1]} (–¥–æ {goal[2]})\n"

    if failed:
        response += "\nüòû –ü—Ä–æ–≤–∞–ª–µ–Ω–Ω—ã–µ —Ü–µ–ª–∏:\n"
        for goal in failed:
            response += f"- {goal[1]} (–¥–æ {goal[2]})\n"

    await update.message.reply_text(response)



def build_sentiment_plot(dates, scores, period: str, user_id: int) -> str:
    # –ê–≥—Ä–µ–≥–∞—Ü–∏—è compound-—Å–∫–æ—Ä–æ–≤ –ø–æ –Ω–µ–¥–µ–ª—è–º –∏–ª–∏ –º–µ—Å—è—Ü–∞–º
    groups = {}
    for dt, sc in zip(dates, scores):
        if period == 'week':
            key = f"W{dt.isocalendar()[1]}-{dt.year}"  # –ù–µ–¥–µ–ª—è-–≥–æ–¥
        else:
            key = dt.strftime('%Y-%m')  # –ú–µ—Å—è—Ü-–≥–æ–¥
        groups.setdefault(key, []).append(sc)

    labels = sorted(groups.keys())
    means = [sum(groups[k]) / len(groups[k]) for k in labels]

    # –†–∏—Å—É–µ–º –≥—Ä–∞—Ñ–∏–∫
    plt.figure()
    plt.plot(labels, means)
    plt.title(f"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ ({period.capitalize()})")
    plt.xlabel(period.capitalize())
    plt.ylabel("–°—Ä–µ–¥–Ω–∏–π Compound Score")
    plt.xticks(rotation=45)
    plt.tight_layout()

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º
    img_fname = os.path.join('images', f'sentiment_{user_id}_{period}.png')
    plt.savefig(img_fname)
    plt.close()
    return img_fname


def get_sentiment_score(text: str) -> float:
    from snownlp import SnowNLP
    from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
    _vader = SentimentIntensityAnalyzer()
    if re.search(r"[–ê-–Ø–∞-—è–Å—ë]", text):
        s = SnowNLP(text)
        return (s.sentiments - 0.5) * 2
    else:
        return _vader.polarity_scores(text)["compound"]


async def sentiment_trend(update: Update, context: ContextTypes.DEFAULT_TYPE,
                          period_type: str, period_count: int):
    """
    period_type: 'days', 'weeks' –∏–ª–∏ 'months'
    period_count: —Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ
    """
    user_id = update.effective_user.id
    now = datetime.now()

    # 1. –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ø–µ—Ä–∏–æ–¥–∞
    if period_type == 'days':
        start_dt = (now - timedelta(days=period_count - 1)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt   = now
    elif period_type == 'weeks':
        monday = now - timedelta(days=now.weekday())
        start_dt = (monday - timedelta(weeks=period_count - 1)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt   = now
    else:  # months
        first_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        start_dt = first_of_month - relativedelta(months=period_count - 1)
        end_dt   = first_of_month + relativedelta(months=1)

    start_date = start_dt.strftime("%Y-%m-%d %H:%M:%S")
    end_date   = end_dt.strftime("%Y-%m-%d %H:%M:%S")

    # 2. –ó–∞–±–∏—Ä–∞–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏
    entries = get_entries(user_id, start_date, end_date)
    if not entries:
        return await update.message.reply_text("üìä –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.")

    # 3. –ì—Ä—É–ø–ø–∏—Ä—É–µ–º compound-—Å–∫–æ—Ä—ã –ø–æ –±–∏–Ω–∞–º
    buckets = {}
    for entry in entries:
        # entry = (id, date_str, text, image_paths_str)
        _, date_str, text, _ = entry
        dt = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
        if period_type == 'days':
            key = dt.strftime("%Y-%m-%d")
        elif period_type == 'weeks':
            iso = dt.isocalendar()  # (year, week_num, weekday)
            key = f"W{iso[1]}-{iso[0]}"
        else:  # months
            key = dt.strftime("%Y-%m")
        score = get_sentiment_score(text or "")
        buckets.setdefault(key, []).append(score)

    # 4. –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –º–µ—Ç–∫–∏ –∏ —Å—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
    labels = []
    means  = []
    if period_type == 'days':
        for i in range(period_count):
            day_dt = start_dt + timedelta(days=i)
            lbl = day_dt.strftime("%Y-%m-%d")
            labels.append(day_dt.strftime("%d.%m"))
            vals = buckets.get(lbl, [])
            means.append(sum(vals)/len(vals) if vals else 0)
    elif period_type == 'weeks':
        curr = start_dt
        for _ in range(period_count):
            iso = curr.isocalendar()
            lbl = f"W{iso[1]}-{iso[0]}"
            labels.append(lbl)
            vals = buckets.get(lbl, [])
            means.append(sum(vals)/len(vals) if vals else 0)
            curr += timedelta(weeks=1)
    else:  # months
        curr = start_dt
        for _ in range(period_count):
            lbl = curr.strftime("%Y-%m")
            labels.append(lbl)
            vals = buckets.get(lbl, [])
            means.append(sum(vals)/len(vals) if vals else 0)
            curr += relativedelta(months=1)

    # 5. –°—Ç—Ä–æ–∏–º –≥—Ä–∞—Ñ–∏–∫
    plt.figure()
    plt.plot(labels, means, marker='o')
    title_map = {'days': '12 –¥–Ω–µ–π', 'weeks': '10 –Ω–µ–¥–µ–ª—å', 'months': '6 –º–µ—Å—è—Ü–µ–≤'}
    plt.title(f"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ ({title_map[period_type]})")
    plt.xlabel({'days':'–î–∞—Ç–∞','weeks':'–ù–µ–¥–µ–ª—è-–ì–æ–¥','months':'–ú–µ—Å—è—Ü'}[period_type])
    plt.ylabel("Avg Compound Score")
    plt.xticks(rotation=45)
    plt.tight_layout()

    # 6. –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
    os.makedirs("images", exist_ok=True)
    img_path = os.path.join("images", f"sentiment_{user_id}_{period_type}.png")
    plt.savefig(img_path)
    plt.close()
    with open(img_path, "rb") as img:
        await context.bot.send_photo(chat_id=update.effective_chat.id, photo=img)

# –û–±—ë—Ä—Ç–∫–∏
async def sentiment_days(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await sentiment_trend(update, context, period_type='days',   period_count=12)

async def sentiment_weeks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await sentiment_trend(update, context, period_type='weeks',  period_count=10)

async def sentiment_months(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await sentiment_trend(update, context, period_type='months', period_count=6)


async def summary_period(update: Update, context: ContextTypes.DEFAULT_TYPE, period: str):
    user_id = update.effective_user.id
    now = datetime.now()

    # 1) –ì—Ä–∞–Ω–∏—Ü—ã –ø–µ—Ä–∏–æ–¥–∞
    if period == 'week':
        start_dt = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0)
        end_dt   = (start_dt + timedelta(days=6)).replace(hour=23, minute=59, second=59)
        period_name = '–Ω–µ–¥–µ–ª—é'
    else:  # 'month'
        start_dt = now.replace(day=1, hour=0, minute=0, second=0)
        nxt = start_dt.replace(day=28) + timedelta(days=4)
        end_dt   = (nxt.replace(day=1) - timedelta(seconds=1)).replace(hour=23, minute=59, second=59)
        period_name = '–º–µ—Å—è—Ü'

    start_date = start_dt.strftime("%Y-%m-%d %H:%M:%S")
    end_date   = end_dt.strftime("%Y-%m-%d %H:%M:%S")

    # 2) –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å–∏
    entries = get_entries(user_id, start_date, end_date)
    if not entries:
        await update.message.reply_text(f"üìÑ –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ {period_name}.")
        return

    # 3) –°—á–∏—Ç—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç—ã –∏ —Å—á–∏—Ç–∞–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
    probs = []
    texts = []
    for _id, _date, entry_text, _imgs in entries:
        if not entry_text:
            continue
        score = get_sentiment_score(entry_text)   # ‚àà[-1;1]
        prob = (score + 1) / 2                    # ‚àà[0;1]
        probs.append(prob)
        texts.append(entry_text)

    total = len(probs)
    pos = sum(1 for p in probs if p > 0.6)
    neg = sum(1 for p in probs if p < 0.4)
    neu = total - pos - neg

    # 4) –û–±—â–µ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ
    if pos > neg:
        mood_label = '–ø–æ–∑–∏—Ç–∏–≤–Ω–æ–µ'
    elif neg > pos:
        mood_label = '–Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–µ'
    else:
        mood_label = '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ'

    # 5) –ö–ª—é—á–µ–≤—ã–µ —Ñ—Ä–∞–∑—ã —á–µ—Ä–µ–∑ YAKE
    full_text = " ".join(texts)
    kw = yake.KeywordExtractor(lan="ru", n=3, top=5)
    keywords = kw.extract_keywords(full_text)
    top_phrases = [phrase for phrase, _ in keywords][:3]

    # 6) –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—é–º–µ
    summary = (
        f"üìÑ –†–µ–∑—é–º–µ –∑–∞ {period_name}:\n"
        f"üìå –ó–∞–ø–∏—Å–µ–π: {total}\n"
        f"‚úÖ –ü–æ–∑–∏—Ç–∏–≤–Ω—ã—Ö: {pos}\n"
        f"‚ö†Ô∏è –ù–µ–≥–∞—Ç–∏–≤–Ω—ã—Ö: {neg}\n"
        f"‚ÑπÔ∏è –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã—Ö: {neu}\n"
        f"üîç –û–±—â–µ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {mood_label}"
    )
    if top_phrases:
        summary += f"\nüîë –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ–º—ã: {', '.join(top_phrases)}"

    await update.message.reply_text(summary)

# –û–±—ë—Ä—Ç–∫–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥
async def summary_week(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await summary_period(update, context, period='week')

async def summary_month(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await summary_period(update, context, period='month')

async def callback_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    entry_id = int(query.data.split(":")[1])
    delete_entry_from_db(entry_id)
    # –º–æ–∂–Ω–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ images/
    await query.edit_message_text("‚úÖ –ó–∞–ø–∏—Å—å —É–¥–∞–ª–µ–Ω–∞.")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—á–∞–ª–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
async def callback_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    entry_id = int(query.data.split(":")[1])
    context.user_data["edit_id"] = entry_id
    await query.message.reply_text("‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è —ç—Ç–æ–π –∑–∞–ø–∏—Å–∏ (–∏–ª–∏ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã).")
    return WAITING_EDIT

# –ü—Ä–∏—ë–º –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
async def receive_edited_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    new_text = update.message.text.strip()
    entry_id = context.user_data.get("edit_id")
    update_entry_in_db(entry_id, new_text)
    await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –∑–∞–ø–∏—Å–∏ –æ–±–Ω–æ–≤–ª—ë–Ω.")
    return ConversationHandler.END

# –û—Ç–º–µ–Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
async def cancel_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    return ConversationHandler.END

async def stats_daily_trend(update: Update, context: ContextTypes.DEFAULT_TYPE):
    import os
    import matplotlib.pyplot as plt
    from datetime import datetime, timedelta
    from database import get_entries

    user_id = update.effective_user.id
    now = datetime.now()

    # 1) –°–æ–±–∏—Ä–∞–µ–º –∑–∞–ø–∏—Å–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 60 –¥–Ω–µ–π (—á—Ç–æ–±—ã —Å—Ä–∞–≤–Ω–∏—Ç—å 30 vs –ø—Ä–µ–¥—ã–¥—É—â–∏–µ 30)
    start_60 = (now - timedelta(days=59)).replace(hour=0, minute=0, second=0, microsecond=0)
    entries = get_entries(
        user_id,
        start_60.strftime("%Y-%m-%d %H:%M:%S"),
        now.strftime("%Y-%m-%d %H:%M:%S")
    )

    # 2) –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ (—Ç–æ–ª—å–∫–æ –¥–∞—Ç–∞ YYYY-MM-DD)
    counts_map = {}
    for entry in entries:
        # unpack: entry is (id, date, text, image_paths)
        _, date_str, _, _ = entry
        day = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S").strftime("%Y-%m-%d")
        counts_map[day] = counts_map.get(day, 0) + 1

    # 3) –ì–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–∫–∏ –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 30 –¥–Ω–µ–π
    labels = []
    values = []
    for i in range(29, -1, -1):
        d = (now - timedelta(days=i)).strftime("%Y-%m-%d")
        labels.append((now - timedelta(days=i)).strftime("%d.%m"))
        values.append(counts_map.get(d, 0))

    # 4) –°—á–∏—Ç–∞–µ–º –æ–±—â–µ–µ –∑–∞ —Ç–µ–∫—É—â–∏–µ –∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ 30 –¥–Ω–µ–π
    total_current = sum(values)
    total_prev = sum(
        counts_map.get((now - timedelta(days=i)).strftime("%Y-%m-%d"), 0)
        for i in range(30, 60)
    )
    if total_prev:
        change = (total_current - total_prev) / total_prev * 100
        sign = "+" if change >= 0 else ""
        change_str = f"{sign}{change:.0f}%"
    else:
        change_str = "–Ω/–¥"

    # 5) –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤—É—é —Å–≤–æ–¥–∫—É
    summary = (
        f"üìä –¢—Ä–µ–Ω–¥ –∑–∞–ø–∏—Å–µ–π –∑–∞ 30 –¥–Ω–µ–π:\n"
        f"‚úèÔ∏è –í—Å–µ–≥–æ: {total_current}\n"
        f"üìà –ò–∑–º–µ–Ω–µ–Ω–∏–µ –∫ –ø—Ä–µ–¥—ã–¥—É—â–∏–º 30 –¥–Ω—è–º: {change_str}"
    )
    await update.message.reply_text(summary)

    # 6) –°—Ç—Ä–æ–∏–º –ª–∏–Ω–µ–π–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫
    plt.figure()
    plt.plot(labels, values, marker='o')
    plt.title("–ó–∞–ø–∏—Å–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π")
    plt.xlabel("–î–∞—Ç–∞")
    plt.ylabel("–ß–∏—Å–ª–æ –∑–∞–ø–∏—Å–µ–π")
    plt.xticks(rotation=45)
    plt.tight_layout()

    # 7) –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É
    os.makedirs("images", exist_ok=True)
    img_path = f"images/stats_30days_{user_id}.png"
    plt.savefig(img_path)
    plt.close()

    with open(img_path, "rb") as img:
        await context.bot.send_photo(chat_id=update.effective_chat.id, photo=img)